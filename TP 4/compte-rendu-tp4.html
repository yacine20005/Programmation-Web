<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="UTF-8">
    <title>Compte-rendu de TP2</title>
    <link rel="stylesheet" type="text/css" href="compte-rendu-tp.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap"
      rel="stylesheet">
  </head>
  <body>
    <h1 class="centered">Compte-rendu de TP4</h1>
    <div class="right">
      <p>
        Yacine HAMADOUCHE <br>
        Gavau--Pelissier Liam
      </p>
    </div>
    <h2>Exercice 1 : Hello World &nbsp;!</h2>
    <ol>
      <li>
        <h3>Recopiez la page Web exo1.html dans votre répertoire tp4.</h3>
        C'est fait !
        <h3>Que se passe-t-il lorsque l'on visualise la page ?</h3>
        Lors de la visualisation de la page, <i>Hello</i> est affiché dans la
        console du navigateur.
        <h3>Comment fait-on pour ouvrir la console avec Firefox ?</h3>
        Il est possible d'ouvrir la console de Firefox en effectuant un
        <code>clic droit</code> puis en selectionnant <code>inspecter</code>, et
        <code>console</code>
        <h3>Et avec Chrome ?</h3>
        Même chose, il est de plus possible d'y accéder avec le raccourci
        <code>CTRL + SHIFT + J</code>
      </li>
      <li>
        <h3>Mettez l'ancien code en commentaire.</h3>
        C'est fait !
        <h3>
          Ecrivez un code permettant d'afficher, toujours dans la console, les
          nombres de 0 à 2023 inclus (il n'est pas nécessaire de faire une
          fonction pour l'instant).
        </h3>
        <pre>
          for (let a = 0; a &lt; 2024; a++) {
            console.log(a)
          }
        </pre>
        Une boucle for est utilisée avec une variable <code>a</code> initialisée
        en 0. <br>
        La boucle continuera à s'exécuter tant que la valeur de
        <code>a</code> est inférieure à 2024. <br>
        À chaque itération de la boucle, la valeur de <code>a</code> est
        affichée dans la console. <br>
        Après chaque itération, la valeur de <code>a</code> est incrémentée
        grâce à <code>a++</code>.
      </li>
      <li>
        <h3>Mettez l'ancien code en commentaire.</h3>
        C'est fait !
        <h3>
          Réécrivez un nouveau code code pour afficher dans la console les
          nombres divisibles par 2 ou par 3 allant de 0 à 2023 <br>
          inclus : 0, 2, 3, 4, 6, 8, …, 2018, 2019, 2020, 2022.
        </h3>
        <pre>
          for (let a = 0; a &lt; 2024; a++) {
            if (a % 2 == 0 || a % 3 == 0) {
              console.log(a);
            }
          }
        </pre>
        La boucle est toujours utilisée avec la même structure et valeurs que
        précédemment. <br>
        Sauf que maintenant à chaque itération, une condition est ajoutée pour
        vérifier si a est divisible par 2 ou par 3. <br>
        Pour cela on utilise <code>modulo</code> pour vérifier si le reste de la
        division de a par 2 ou par 3 est égal à zéro (ce qui signifie que a est
        divisible par 2 ou par 3). <br>
        Si la condition est vraie alors le nombre a est affiché dans la console.
      </li>
      <li>
        <h3>
          Commentez l'ancien code et écrire une fonction (que vous nommerez de
          façon claire et intelligente) prenant un entier en paramètre et
          affichant sur la console les nombres divisibles par 2 ou par 3 allant
          de de 0 à cet entier (inclus). Puis écrivez un code de test de la
          fonction avec les valeurs 7 et puis 10.
        </h3>
        <pre>
          const multiple_de_2_ou_3 = function(val) {
            for (let a = 0; a &lt;= val; a++) {
                if (a % 2 == 0 || a % 3 == 0) {
                    console.log(a);
                }
            }
        }
       </pre
        >
        Le code de départ est maintenant dans une fonction nommée
        multiple_de_2_ou_3. <br>
        Cette fonction prend <code>val</code>, qui est l'entier jusqu'auquel
        nous voulons afficher les nombres divisibles par 2 ou par 3. <br>
        La boucle parcourt les nombres de 0 à val inclus. <br>
        La condition vérifie si le nombre actuel est divisible par 2 ou par 3.
        <br>
        Si c'est le cas, le nombre est affiché dans la console.
        <br>
        <h3>Que se passe-t-il si on teste la fonction avec la valeur -1 ?</h3>
        La fonction commence par exécuter la boucle de 0 à -1. <br>
        Cependant, cela ne générera aucune itération car la condition a &lt;=
        val ne sera jamais vraie puisque val est -1.
      </li>
    </ol>
    <h2>Exercice 2 : Damier</h2>
    <ol>
      <li>
        <h3>Expliquez ce que fait la première ligne du script</h3>
        La première ligne permet de se mettre en mode <code>strict</code> pour
        le restant du script ce qui permettra d'éviter les
        <i>erreurs silencieuses</i> du <code>JavaScript</code>
      </li>
      <li>
        <h3>
          Expliquez comment faire pour ajouter un enfant ou une classe à un
          élément, puis expliquer comment fonctionne la fonction makeCell.
        </h3>
        Pour ajouter un enfant à un élément parent nous utilisons
        <code>.appendChild(element)</code> <br>
        Pour ajouter une classe nous utilisons cette fois
        <code>.classList.add(element)</code> <br>
        <pre>
          const makeCell = function(id) 
          const table = document.getElementById(id);
          const row = document.createElement("tr");
          const cell = document.createElement("td");
          row.appendChild(cell);
          table.appendChild(row);
        </pre>
        La fonction makeCell va dans un premier temps récupérer l'élément grâce
        à l'id donner en argument <br>
        Ensuite celui-ci va créer à la suite respectivement une ligne et une
        colonne <br>
        Pour enfin ajouter la colonne à la ligne et la ligne à la table.
      </li>
      <li>
        <h3>
          Remplissez le contenu de la fonction makeLine de sorte que l'appel à
          makeLine(5, "table-2"); transforme la table d'identifiant "table-2" en
          un tableau d'une ligne et cinq colonnes.
        </h3>
        <pre>
          const makeLine = function (nb, id) {
            const table = document.getElementById(id);
            const row = document.createElement("tr");
            for (let i = 0; i &lt; nb; i++) {
              const cell = document.createElement("td");
              row.appendChild(cell);
            }
            table.appendChild(row);
          };
        </pre>
        Cette fonction crée une nouvelle ligne, <br>
        Puis avec une boucle for, elle crée le nombre voulu de colonnes
        &lt;td&gt; <br>
        les attaches à la ligne. <br>
        Enfin, elle attache la ligne à la table.
      </li>
      <li>
        <h3>
          Remplissez le contenu de la fonction makeSquare de sorte que l'appel à
          makeSquare(8, "table-3"); transforme la table d'identifiant "table-3"
          en un tableau de huit lignes et huit colonnes.
        </h3>
        <pre>
          const makeSquare = function (size, id) {
            const table = document.getElementById(id);
            for (let i = 0; i &lt; size; i++) {
              const row = document.createElement("tr");
              for (let j = 0; j &lt; size; j++) {
                const cell = document.createElement("td");
                row.appendChild(cell);
              }
              table.appendChild(row);
            }
          };
        </pre>
        Cette fonction utilise deux boucles, une pour les lignes et une pour les
        colonnes. <br>
        Elle crée une nouvelle ligne pour chaque itération de la première boucle
        <br>
        Puis à l'intérieur de cette boucle, elle crée le nombre spécifié de
        cellules et les attache à la ligne. <br>
        Enfin, elle attache la ligne à la table.
      </li>
      <li>
        <h3>
          Vérifiez que la table d'identifiant "table-4" est maintenant un
          tableau de trois lignes et trois colonnes. <br>
          Si ce n'est pas le cas, reprenez la fonction précédente.
        </h3>
        C'est fait !
      </li>
      <li>
        <h3>
          Complétez le style de la balise style du document pour définir une
          case noire et une case blanche et utilisez ce style pour les cases de
          chacun des quatre tableaux (vous êtes libre de commencer par une case
          blanche ou par une case noire).
        </h3>
        Deux nouvelles classes CSS ont été ajoutées <code>.noir</code> et
        <code>.blanc</code>. <br>
        Ces classes définissent le fond des cellules respectivement en noir et
        en blanc.
        <pre>
          const makeCell = function (id) {
            const table = document.getElementById(id);
            const row = document.createElement("tr");
            const cell = document.createElement("td");
            cell.classList.add("noir")
            row.appendChild(cell);
            table.appendChild(row);
          };
        </pre>
        La classe noir est ajoutée à la cellule créée avec
        <code>cell.classList.add("noir")</code>.
        <pre>
          const makeLine = function (nb, id) {
            const table = document.getElementById(id);
            const row = document.createElement("tr");
            for (let i = 0; i &lt; nb; i++) {
              const cell = document.createElement("td");
              if (i % 2 == 0) {
                cell.classList.add("noir")
              }
              else if (i % 2 == 1) {
                cell.classList.add("blanc")
              }
              row.appendChild(cell);
            }
            table.appendChild(row);
          };
    
          const makeSquare = function (size, id) {
            const table = document.getElementById(id);
            for (let i = 0; i &lt; size; i++) {
              const row = document.createElement("tr");
              for (let j = 0; j &lt; size; j++) {
                const cell = document.createElement("td");
                if ((i + j) % 2 == 0) {
                cell.classList.add("noir")
                }
                else if ((i + j) % 2 == 1) {
                cell.classList.add("blanc")
                }
                row.appendChild(cell);
              }
              table.appendChild(row);
            }
          };
        </pre>
        Enfin pour <code>makeLine</code> et <code>makeSquare</code> les classes
        sont ajoutées en fonction de l'indice de la boucle grâce à
        <code>if (i % 2 == 0)</code> et <code> else if (i % 2 == 1)</code>.
        <br>
        Si celle-ci est pair la couleur sera noir sinon blanche. <br>
        Ainsi pour <code>makeSquare</code> comme 2 boucles sont imbriqués entre
        elles nous prenons la somme des deux indices et vérifions si celle-ci
        est pair ou non : <code>if ((i + j) % 2 == 0)</code>;
        <code>else if ((i + j) % 2 == 1)</code>.
      </li>
      <li>
        <h3>
          Ajoutez un style de case marron puis commentez votre code de la
          fonction makeSquare et réécrivez-la pour ajouter un dernier paramètre
          à makeSquare ; ce paramètre pouvant être vrai ou faux. Si le paramètre
          est vrai, alors il faudra afficher la diagonale en marron.
        </h3>
        Une nouvelle classe CSS a été ajoutée pour les cellules marron
        <code>td.marron</code> qui permet de définir le fond des cellules en
        marron <br>
        <pre>
          const makeSquare = function (size, id, brown) {
            const table = document.getElementById(id);
            for (let i = 0; i &lt; size; i++) {
              const row = document.createElement("tr");
              for (let j = 0; j &lt; size; j++) {
                const cell = document.createElement("td");
                if (brown == true && i == j) {
                  cell.classList.add("marron")
                }
                else {
                  if ((i + j) % 2 == 0) {
                    cell.classList.add("noir")
                  }
                  else {
                    cell.classList.add("blanc")
                  }
                }
                row.appendChild(cell);
              }
              table.appendChild(row);
            }
          };
        </pre>
        Un nouveau paramètre <code>brown</code> a été ajouté afin de d'actionner
        l'apparition ou non de la diagonale marron <br>
        Avec cette nouvelle fonction, si <code>brown</code> est vrai et que les
        deux boucles se trouvent à la même indice alors la classe marron est
        ajoutée sinon ça sera la classe <code>noir</code> ou
        <code>blanc</code> qui sera ajoutée
      </li>
      <li>
        <h3>
          Testez en affichant en marron la diagonale du premier carré (mais pas
          celle du second).
        </h3>
        C'est fait !
      </li>
    </ol>
    <h2>Exercice 3 : On fera en fonction…</h2>
    <ol>
      <li>
        <h3>
          Copiez-collez le document exo2b.html et nommez exo3.html votre copie.
          Ci-dessous, vous effectuerez vos modifications sur ce nouveau document
          exo3.html.
        </h3>
        C'est fait !
      </li>
      <li>
        <h3>
          Faites en sorte que la fonction makeCell prenne un argument
          supplémentaire, qui sera la couleur (black, white ou brown) de la
          case. <br>
          Par exemple, si j'appelle makeCell("table-1","brown"), on dessinera
          une case de classe "brown", qui aura vocation à être dessinée en
          marron comme indiqué dans les informations de style du document.
        </h3>
        <pre>
          const makeCell = function (id, color) {
            const table = document.getElementById(id);
            const row = document.createElement("tr");
            const cell = document.createElement("td");
            cell.classList.add(color)
            row.appendChild(cell);
            table.appendChild(row);
          };
        </pre>
        Un deuxième paramètre <code>color</code> a été ajouté à la fonction
        <code>makeCell</code>. Cet argument représente la couleur de la case et
        sera utilisé pour ajouter la classe correspondante à la cellule. <br>
        La classe est ajoutée à la cellule en utilisant
        <code>cell.classList.add(color)</code> <br>
      </li>
      <li>
        <h3>
          Définissez une fonction color(i,j) qui renvoie la couleur de la case
          en ligne i et colonne j d'un damier carré sans cases marron (comme à
          la question 6 de l'exercice 2).
        </h3>
        <pre>
          const color = function (i, j) {
            if ((i + j) % 2 == 0) {
              return "black";
            } 
            else {
              return "white";
            }
          };
        </pre>
        Cette fonction prend i et j et utilise la même logique que celle
        utilisée pour déterminer la couleur des cases dans
        <code>makeSquare</code>.
      </li>
      <li>
        <h3>
          Redéfinissez la fonction makeSquare pour que, outre l'identifiant du
          tableau à transformer et la dimension de la grille qu'elle doit
          dessiner, le troisième argument que prend cette fonction soit non plus
          un booléen qui dira si on doit peindre (ou non) en marron la diagonale
          de la grille, mais une fonction d'affichage qui associera à paire
          (i,j) la couleur de la case en ligne i et colonne j. <br>
          Notez que dans cette question, la fonction makeSquare prend en
          troisième argument une fonction, comme la fonction doItTwice vue en
          cours. Par exemple, si j'appelle makeSquare(3, "table-4", color), où
          color est la fonction de la question 3, on dessinera 3×3 cases, et la
          case en ligne 1 et colonne 2 sera de couleur color(1,2)
        </h3>
        <pre>
          const makeSquare = function (size, id, color) {
            const table = document.getElementById(id);
            for (let i = 0; i &lt; size; i++) {
              const row = document.createElement("tr");
              for (let j = 0; j &lt; size; j++) {
                const cell = document.createElement("td");
                cell.classList.add(color(i, j));
                row.appendChild(cell);
              }
              table.appendChild(row);
            }
          };
        </pre>
        Le troisième argument est désormais la fonction color qui sera utilisée
        pour déterminer la couleur de chaque case dans la grille. <br>
        La fonction est appelée avec les indices de ligne i et de colonne j à
        chaque boucle <br>
        Une fois que la couleur de la case est obtenue grâce à la fonction, la
        classe correspondante est ajoutée à la cellule.
      </li>
      <li>
        <h3>
          Définissez enfin une fonction diagonalColor dont le seul argument est
          un booléen, et telle que l'appel à makeSquare(size, id,
          diagonalColor(true)) transformera la table d'identifiant id en une
          grille dont la diagonale sera marron, tandis que l'appel à
          makeSquare(size, id, diagonalColor(false)) transformera cette table en
          une grille dont la diagonale n'aura pas de couleur particulière (par
          rapport aux autres cases de la grille).
        </h3>
        <pre>
          makeSquare(8, "table-3", diagonalColor(false));
          makeSquare(3, "table-4", diagonalColor(true));
          const makeSquare = function (size, id, diagonalColor) {
            const table = document.getElementById(id);
            for (let i = 0; i &lt; size; i++) {
              const row = document.createElement("tr");
              for (let j = 0; j &lt; size; j++) {
                const cell = document.createElement("td");
                cell.classList.add(diagonalColor(i, j));
                row.appendChild(cell);
              }
              table.appendChild(row);
            }
          };

          const diagonalColor = function (bool) {
            return function (i, j) {
              if (bool && i == j) {
                return "brown";
              } else {
                return color(i, j);
              }
            };
          };
        </pre>
        diagonalColor qui prend un booléen bool comme argument et retourne une
        fonction anonyme qui prend deux paramètres, i et j, représentant les
        indices de ligne et de colonne de la cellule dans la grille. <br>
        Si le booléen passé à diagonalColor est vrai et que les indices de ligne
        et de colonne (i et j) sont égaux, la fonction retourne la couleur
        "brown", indiquant que cette case est sur la diagonale et doit être
        marron. <br>
        Sinon, la fonction appelle simplement la fonction color(i, j) pour
        déterminer la couleur de la case, en utilisant la logique habituelle
        pour un damier noir et blanc.
      </li>
    </ol>
  </body>
</html>
